From 8c8cc6c143753c429939cda408960621ee6af836 Mon Sep 17 00:00:00 2001
From: OpenEmbedded <oe.patch@oe>
Date: Wed, 27 Jan 2021 11:11:01 +0800
Subject: [PATCH] gi361_add_pl_ps_spi_printk

Signed-off-by: OpenEmbedded <oe.patch@oe>
---
 drivers/spi/spi-mem.c          |  20 +++
 drivers/spi/spi-xilinx.c       | 289 ++++++++++++++++++++++++++++++++++++++++-
 drivers/spi/spi-zynqmp-gqspi.c |  81 ++++++++++++
 drivers/spi/spi.c              |  69 +++++++++-
 drivers/spi/spidev.c           | 195 +++++++++++++++++++++++++++
 5 files changed, 649 insertions(+), 5 deletions(-)

diff --git a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
index c2c5029..112e70e 100644
--- a/drivers/spi/spi-mem.c
+++ b/drivers/spi/spi-mem.c
@@ -195,6 +195,7 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 	struct spi_message msg;
 	u8 *tmpbuf;
 	int ret;
+	int i = 0;
 
 	if (!spi_mem_supports_op(mem, op))
 		return -ENOTSUPP;
@@ -298,6 +299,25 @@ int spi_mem_exec_op(struct spi_mem *mem, const struct spi_mem_op *op)
 		totalxferlen += op->data.nbytes;
 	}
 
+    printk("spi_mem_exec_op cmd buswidth=0x%x \n",op->cmd.buswidth);
+    printk("spi_mem_exec_op cmd opcode=0x%x \n",op->cmd.opcode);
+    printk("spi_mem_exec_op addr nbytes=0x%x \n",op->addr.nbytes);
+    printk("spi_mem_exec_op addr buswidth=0x%x \n",op->addr.buswidth);
+    printk("spi_mem_exec_op addr val=0x%x \n",op->addr.val);
+
+    printk("spi_mem_exec_op dummy nbytes=0x%x \n",op->dummy.nbytes);
+    printk("spi_mem_exec_op dummy buswidth=0x%x \n",op->dummy.buswidth);
+
+    printk("spi_mem_exec_op xferpos=%d \n",xferpos);
+    for(i = 0; i < xferpos; i++)
+    {
+        printk("spi_mem_exec_op len=%d, cs_change=%d, tx_nbits=%d, rx_nbits=%d, bits_per_word=%d, delay_usecs=%d, speed_hz=%d, dummy=%d, stripe=%d \n",
+            xfers[i].len, xfers[i].cs_change, xfers[i].tx_nbits, xfers[i].rx_nbits,
+            xfers[i].bits_per_word, xfers[i].delay_usecs, xfers[i].speed_hz, xfers[i].dummy,
+            xfers[i].stripe);
+    }
+
+
 	ret = spi_sync(mem->spi, &msg);
 
 	kfree(tmpbuf);
diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c
index e2a01f9..9d9d433 100644
--- a/drivers/spi/spi-xilinx.c
+++ b/drivers/spi/spi-xilinx.c
@@ -84,6 +84,19 @@
 /* Command used for Dummy read Id */
 #define SPI_READ_ID		0x9F
 
+
+/* Canonical definitions for peripheral PL_GPIO */
+//#define XPAR_GPIO_0_BASEADDR 0x800E0000
+#define XPAR_GPIO_0_SIZE 0x1000
+#define XPAR_GPIO_0_BASEADDR_PHY 0x800E0000
+#define XPAR_GPIO_0_HIGHADDR 0x800EFFFF
+#define XPAR_GPIO_0_DEVICE_ID 0
+#define XPAR_GPIO_0_INTERRUPT_PRESENT 0
+#define XPAR_GPIO_0_IS_DUAL 1
+unsigned char * XPAR_GPIO_0_BASEADDR = 0;
+
+
+
 /**
  * struct xilinx_spi - This definition define spi driver instance
  * @regs:		virt. address of the control registers
@@ -138,9 +151,19 @@ struct xilinx_spi {
 static void xspi_read_rx_fifo_##size(struct xilinx_spi *xqspi)		\
 {									\
 	int i;								\
+	unsigned int gpioStatus = 0; \
 	int count = (xqspi->bytes_to_receive > xqspi->buffer_size) ?	\
 			xqspi->buffer_size : xqspi->bytes_to_receive;	\
 	u32 data;							\
+	printk("xspi_read_rx_fifo_%d,  count=%d, rx_bus_width=%d \r\n",size,count,xqspi->rx_bus_width); \
+	if(XPAR_GPIO_0_BASEADDR != NULL) \
+	{ \
+	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR); \
+	    printk("read gpioStatus=0x%x \r\n",gpioStatus); \
+	    gpioStatus = gpioStatus & (~( (1 << 22) | (1 << 24 ) )); \
+	    printk("write gpioStatus=0x%x \r\n",gpioStatus); \
+	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); \
+	} \
 	for (i = 0; i < count; i += (size/8)) {				\
 		data = readl_relaxed(xqspi->regs + XSPI_RXD_OFFSET);	\
 		if (xqspi->rx_ptr)					\
@@ -149,6 +172,7 @@ static void xspi_read_rx_fifo_##size(struct xilinx_spi *xqspi)		\
 	xqspi->bytes_to_receive -= count;				\
 	if (xqspi->rx_ptr)						\
 		xqspi->rx_ptr += count;					\
+	printk("xspi_read_rx_fifo_%d out count=%d \r\n\r\n",size,count); \
 }
 
 /**
@@ -163,9 +187,19 @@ static void xspi_read_rx_fifo_##size(struct xilinx_spi *xqspi)		\
 static void xspi_fill_tx_fifo_##size(struct xilinx_spi *xqspi)		\
 {									\
 	int i;								\
+	unsigned int gpioStatus = 0; \
 	int count = (xqspi->bytes_to_transfer > xqspi->buffer_size) ?	\
 			xqspi->buffer_size : xqspi->bytes_to_transfer;	\
 	u32 data = 0;							\
+	printk("xspi_fill_tx_fifo_%d,  count=%d, rx_bus_width=%d\r\n",size,count,xqspi->rx_bus_width); \
+	if(XPAR_GPIO_0_BASEADDR != NULL) \
+	{ \
+	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR); \
+	    printk("read gpioStatus=0x%x \r\n",gpioStatus); \
+	    gpioStatus = gpioStatus | (( (1 << 22) | (1 << 24 ) )); \
+	    printk("write gpioStatus=0x%x \r\n",gpioStatus); \
+	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); \
+	} \
 	for (i = 0; i < count; i += (size/8)) {				\
 		if (xqspi->tx_ptr)					\
 			data = (type)((u8 *)xqspi->tx_ptr)[i];		\
@@ -174,6 +208,7 @@ static void xspi_fill_tx_fifo_##size(struct xilinx_spi *xqspi)		\
 	xqspi->bytes_to_transfer -= count;				\
 	if (xqspi->tx_ptr)						\
 		xqspi->tx_ptr += count;					\
+	printk("xspi_fill_tx_fifo_%d out count=%d \r\n\r\n",size,count); \
 }
 
 XSPI_FIFO_READ(8, u8)
@@ -192,6 +227,10 @@ XSPI_FIFO_WRITE(32, u32)
  */
 static void xspi_write32(u32 val, void __iomem *addr)
 {
+
+    printk("xspi_write32 addr=0x%x, val=0x%x \r\n", addr, val);
+    
+
 	iowrite32(val, addr);
 }
 
@@ -205,6 +244,10 @@ static void xspi_write32(u32 val, void __iomem *addr)
  */
 static unsigned int xspi_read32(void __iomem *addr)
 {
+
+    printk("xspi_read32 addr=0x%x \r\n", addr);
+
+
 	return ioread32(addr);
 }
 
@@ -217,6 +260,9 @@ static unsigned int xspi_read32(void __iomem *addr)
  */
 static void xspi_write32_be(u32 val, void __iomem *addr)
 {
+
+    printk("xspi_write32_be addr=0x%x, val=0x%x \r\n", addr, val);
+
 	iowrite32be(val, addr);
 }
 
@@ -230,6 +276,9 @@ static void xspi_write32_be(u32 val, void __iomem *addr)
  */
 static unsigned int xspi_read32_be(void __iomem *addr)
 {
+    printk("xspi_read32_be addr=0x%x \r\n", addr);
+    
+
 	return ioread32be(addr);
 }
 
@@ -309,10 +358,56 @@ static irqreturn_t xilinx_spi_irq(int irq, void *dev_id)
 	struct xilinx_spi *xspi = spi_master_get_devdata(dev_id);
 	u32 ipif_isr;
 	int status = IRQ_NONE;
+	unsigned int gpioStatus = 0; 
 
 	/* Get the IPIF interrupts, and clear them immediately */
 	ipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
 	xspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);
+	/*
+    if(transfer->tx_nbits == 4 && transfer->rx_nbits == 0)
+    {
+        // write 4 wires
+        if(XPAR_GPIO_0_BASEADDR != NULL) 
+    	{ 
+    	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR); 
+    	    printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+    	    gpioStatus = gpioStatus | (( (1 << 22) | (1 << 24 ) )); 
+    	    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+    	}
+    }
+    else if(transfer->tx_nbits == 0 && transfer->rx_nbits == 4)
+    {
+        // read 4 wires
+        if(XPAR_GPIO_0_BASEADDR != NULL) 
+    	{ 
+    	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR);
+    	    printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+    	    gpioStatus = gpioStatus & (~( (1 << 22) | (1 << 24 ) )); 
+    	    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+    	} 
+	}
+    else if( (transfer->tx_nbits == 0 && transfer->rx_nbits == 1) || 
+             (transfer->tx_nbits == 1 && transfer->rx_nbits == 0))
+    {
+    	// read write 1 wire
+        if(XPAR_GPIO_0_BASEADDR != NULL) 
+    	{ 
+    	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR);
+    	    printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+
+    	    //miso read  bit24
+    	    gpioStatus = gpioStatus & (~((1 << 24 ) )); 
+
+            // mosi write bit22
+    	    gpioStatus = gpioStatus | (( (1 << 22))); 
+    	    
+    	    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+    	} 
+	}
+	//*/
 	if (ipif_isr & XSPI_INTR_TX_EMPTY)  {
 		/* Transmission completed */
 		xspi->rx_fifo(xspi);
@@ -465,10 +560,15 @@ static int xspi_start_transfer(struct spi_master *master,
 {
 	struct xilinx_spi *xqspi = spi_master_get_devdata(master);
 	u32 cr;
+	unsigned int gpioStatus = 0; 
 
 	xqspi->tx_ptr = transfer->tx_buf;
 	xqspi->rx_ptr = transfer->rx_buf;
 
+    printk("xqspi dummy=0x%x\r\n", transfer->dummy);
+
+    printk("xqspi rx_bus_width=0x%x\r\n", xqspi->rx_bus_width);
+    
 	if (transfer->dummy) {
 		xqspi->bytes_to_transfer = (transfer->len - (transfer->dummy/8))
 							+ ((transfer->dummy/8) *
@@ -481,18 +581,121 @@ static int xspi_start_transfer(struct spi_master *master,
 		xqspi->bytes_to_receive = transfer->len;
 	}
 
+    printk("xqspi tx_ptr=0x%x, rx_ptr=0x%x\r\n", xqspi->tx_ptr, xqspi->rx_ptr);
+    printk("xqspi bytes_to_transfer=%d, bytes_to_receive=%d\r\n", xqspi->bytes_to_transfer, xqspi->bytes_to_receive);
+    
+	/* Transmit */
+	if ((xqspi->tx_ptr != NULL) && (xqspi->rx_ptr == NULL)) {
+	    xqspi->bytes_to_receive = 0;
+	}
+	else if ((xqspi->tx_ptr == NULL) && (xqspi->rx_ptr != NULL)) {
+        printk("xqspi bytes_to_transfer=%d, bytes_to_receive=%d\r\n", xqspi->bytes_to_transfer, xqspi->bytes_to_receive);
+
+	    //xqspi->bytes_to_transfer = 0;
+	    xqspi->bytes_to_transfer = xqspi->bytes_to_receive;
+	}
+
+    printk("xqspi bytes_to_transfer=%d, bytes_to_receive=%d\r\n", xqspi->bytes_to_transfer, xqspi->bytes_to_receive);
+    
 	xspi_setup_transfer(qspi, transfer);
+
+    printk("xspi_setup_transfer out\r\n");
+
+    printk("xspi_setup_transfer regs=0x%x\r\n",xqspi->regs);
+
+
+    
 	cr = xqspi->read_fn(xqspi->regs + XSPI_CR_OFFSET);
 	/* Enable master transaction inhibit */
 	cr |= XSPI_CR_TRANS_INHIBIT;
 	xqspi->write_fn(cr, xqspi->regs + XSPI_CR_OFFSET);
-	xqspi->tx_fifo(xqspi);
+
+    printk("xspi_setup_transfer cr=0x%x\r\n",cr);
+
+    printk("xqspi tx_ptr=0x%x, rx_ptr=0x%x\r\n", xqspi->tx_ptr, xqspi->rx_ptr);
+
+
+
+
+    //printk("xqspi tx_nbits=%d, rx_nbits=%d\r\n", transfer->tx_nbits, transfer->rx_nbits);
+
+    
+    //if(transfer->tx_nbits == 4 && transfer->rx_nbits == 0)
+    //{
+        // write 4 wires
+      //  if(XPAR_GPIO_0_BASEADDR != NULL) 
+    //	{ 
+    //	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR); 
+    //	    printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+    //	    gpioStatus = gpioStatus | (( (1 << 22) | (1 << 24 ) )); 
+    //	    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    //	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+    //	}
+    //}
+    ///else if(transfer->tx_nbits == 0 && transfer->rx_nbits == 4)
+    //{
+        // read 4 wires
+      //  if(XPAR_GPIO_0_BASEADDR != NULL) 
+    //	{ 
+    //	    gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR);
+    //	    printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+    //	    gpioStatus = gpioStatus & (~( (1 << 22) | (1 << 24 ) )); 
+    //	    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    //	    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+  //  	} 
+//	}
+   // else if( (transfer->tx_nbits == 0 && transfer->rx_nbits == 1) || 
+     //        (transfer->tx_nbits == 1 && transfer->rx_nbits == 0))
+    //{
+    	// read write 1 wire
+       // if(XPAR_GPIO_0_BASEADDR != NULL) 
+    	//{ 
+    	  //  gpioStatus = ioread32(XPAR_GPIO_0_BASEADDR);
+    	  //  printk("read gpioStatus=0x%x \r\n",gpioStatus); 
+
+    	    //miso read  bit24
+    	 //   gpioStatus = gpioStatus & (~((1 << 24 ) )); 
+
+        //    // mosi write bit22
+    	 //   gpioStatus = gpioStatus | (( (1 << 22))); 
+    	    
+    	//    printk("write gpioStatus=0x%x \r\n",gpioStatus); 
+    	//    iowrite32(gpioStatus, XPAR_GPIO_0_BASEADDR); 
+    	//} 
+	//}
+
+    
+	if ((xqspi->tx_ptr != NULL) && (xqspi->rx_ptr == NULL)) {
+	
+	    printk("xspi_setup_transfer tx_fifo before \r\n");
+	    
+	    xqspi->tx_fifo(xqspi);
+	    
+	    printk("xspi_setup_transfer tx_fifo out\r\n");
+
+	}
+	else if ((xqspi->tx_ptr == NULL) && (xqspi->rx_ptr != NULL)) {
+	
+	    printk("xspi_setup_transfer tx rx_fifo before \r\n");
+	    
+	    xqspi->tx_fifo(xqspi);
+	    
+	    printk("xspi_setup_transfer tx rx_fifo out\r\n");
+	    
+	}
+
+	
 	/* Disable master transaction inhibit */
 	cr &= ~XSPI_CR_TRANS_INHIBIT;
 	xqspi->write_fn(cr, xqspi->regs + XSPI_CR_OFFSET);
+	//xqspi->write_fn(XIPIF_V123B_GINTR_ENABLE,
+	//		xqspi->regs + XIPIF_V123B_DGIER_OFFSET);
+
 	xqspi->write_fn(XIPIF_V123B_GINTR_ENABLE,
 			xqspi->regs + XIPIF_V123B_DGIER_OFFSET);
 
+    printk("xspi_setup_transfer return len=0x%x\r\n",transfer->len);
+
 	return transfer->len;
 }
 
@@ -690,8 +893,13 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	u32 tmp, rx_bus_width, fifo_size;
 	bool startup_block;
 
+    printk("xilinx_spi_probe in \r\n");
+
 	of_property_read_u32(pdev->dev.of_node, "num-cs",
 				&num_cs);
+
+	printk("xilinx_spi_probe read num_cs=%d \r\n", num_cs);
+	
 	if (!num_cs)
 		num_cs = 1;
 
@@ -700,10 +908,17 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	printk("xilinx_spi_probe 2 num_cs=%d ,max_cs=%d \r\n", num_cs, XILINX_SPI_MAX_CS);
+
 	startup_block = of_property_read_bool(pdev->dev.of_node,
 					      "xlnx,startup-block");
 
+    printk("xilinx_spi_probe startup_block=%d \r\n", startup_block);
+    
 	master = spi_alloc_master(&pdev->dev, sizeof(struct xilinx_spi));
+
+	printk("xilinx_spi_probe master=0x%x \r\n", master);
+	
 	if (!master)
 		return -ENODEV;
 
@@ -719,6 +934,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 
 	ret = of_property_read_u32(pdev->dev.of_node, "fifo-size",
 				&fifo_size);
+	printk("xilinx_spi_probe ret=%d \r\n", ret);
+	
 	if (ret < 0) {
 		dev_err(&pdev->dev,
 			"Missing fifo size\n");
@@ -729,6 +946,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 
 	xspi->rx_bus_width = XSPI_ONE_BITS_PER_WORD;
 	for_each_available_child_of_node(pdev->dev.of_node, nc) {
+	    printk("xilinx_spi_probe startup_block=0x%x \r\n", startup_block);
+	    
 		if (startup_block) {
 			ret = of_property_read_u32(nc, "reg",
 						   &cs_num);
@@ -737,6 +956,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 		}
 		ret = of_property_read_u32(nc, "spi-rx-bus-width",
 						&rx_bus_width);
+		printk("xilinx_spi_probe rx_bus_width=0x%x \r\n", rx_bus_width);
+		
 		if (!ret) {
 			xspi->rx_bus_width = rx_bus_width;
 			break;
@@ -744,6 +965,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	}
 
 	xspi->axi_clk = devm_clk_get(&pdev->dev, "axi_clk");
+	printk("xilinx_spi_probe axi_clk=0x%x \r\n", xspi->axi_clk);
+	
 	if (IS_ERR(xspi->axi_clk)) {
 		if (PTR_ERR(xspi->axi_clk) != -ENOENT) {
 			ret = PTR_ERR(xspi->axi_clk);
@@ -758,12 +981,17 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	}
 
 	ret = clk_prepare(xspi->axi_clk);
+	printk("xilinx_spi_probe clk_prepare axi_clk ret=%d \r\n", ret);
+	
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to prepare AXI clock\n");
 		goto put_master;
 	}
 
 	xspi->axi4_clk = devm_clk_get(&pdev->dev, "axi4_clk");
+	printk("xilinx_spi_probe axi4_clk=0x%x \r\n", xspi->axi4_clk);
+
+	
 	if (IS_ERR(xspi->axi4_clk)) {
 		if (PTR_ERR(xspi->axi4_clk) != -ENOENT) {
 			ret = PTR_ERR(xspi->axi4_clk);
@@ -778,12 +1006,15 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	}
 
 	ret = clk_prepare(xspi->axi4_clk);
+	printk("xilinx_spi_probe clk_prepare axi4_clk ret=%d \r\n", ret);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to prepare AXI4 clock\n");
 		goto clk_unprepare_axi_clk;
 	}
 
 	xspi->spi_clk = devm_clk_get(&pdev->dev, "spi_clk");
+	printk("xilinx_spi_probe spi_clk=0x%x \r\n", xspi->spi_clk);
+	
 	if (IS_ERR(xspi->spi_clk)) {
 		if (PTR_ERR(xspi->spi_clk) != -ENOENT) {
 			ret = PTR_ERR(xspi->spi_clk);
@@ -798,6 +1029,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	}
 
 	ret = clk_prepare(xspi->spi_clk);
+	printk("xilinx_spi_probe clk_prepare spi_clk ret=%d \r\n", ret);
+	
 	if (ret) {
 		dev_err(&pdev->dev, "Failed to prepare SPI clock\n");
 		goto clk_unprepare_axi4_clk;
@@ -807,6 +1040,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	pm_runtime_use_autosuspend(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 	ret = pm_runtime_get_sync(&pdev->dev);
+	printk("xilinx_spi_probe pm_runtime_get_sync ret=%d \r\n", ret);
+	
 	if (ret < 0)
 		goto clk_unprepare_all;
 
@@ -818,6 +1053,9 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	xspi->write_fn(XSPI_CR_LOOP, xspi->regs + XSPI_CR_OFFSET);
 	tmp = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
 	tmp &= XSPI_CR_LOOP;
+
+	printk("xilinx_spi_probe tmp=%d \r\n", tmp);
+	
 	if (tmp != XSPI_CR_LOOP) {
 		xspi->read_fn = xspi_read32_be;
 		xspi->write_fn = xspi_write32_be;
@@ -825,6 +1063,8 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 
 	xspi->buffer_size = fifo_size;
 	xspi->irq = platform_get_irq(pdev, 0);
+	printk("xilinx_spi_probe irq=%d \r\n", xspi->irq);
+	
 	if (xspi->irq < 0 && xspi->irq != -ENXIO) {
 		ret = xspi->irq;
 		goto clk_unprepare_all;
@@ -836,9 +1076,11 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 			goto clk_unprepare_all;
 	}
 
+    printk("xilinx_spi_probe xspi_init_hw before \r\n");
 	/* SPI controller initializations */
 	xspi_init_hw(xspi);
-
+    printk("xilinx_spi_probe xspi_init_hw out \r\n");
+    
 	pm_runtime_put(&pdev->dev);
 
 	master->bus_num = pdev->id;
@@ -854,13 +1096,21 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	xspi->bytes_per_word = bits_per_word / 8;
 	xspi->tx_fifo = xspi_fill_tx_fifo_8;
 	xspi->rx_fifo = xspi_read_rx_fifo_8;
+
+    printk("xilinx_spi_probe 8 rx_bus_width=%d \r\n", xspi->rx_bus_width);
+    
+
 	if (xspi->rx_bus_width == XSPI_RX_ONE_WIRE) {
 		if (xspi->bytes_per_word == XSPI_TWO_BITS_PER_WORD) {
 			xspi->tx_fifo = xspi_fill_tx_fifo_16;
 			xspi->rx_fifo = xspi_read_rx_fifo_16;
+			printk("xilinx_spi_probe 16 bytes_per_word=%d \r\n", xspi->bytes_per_word );
+			
 		} else if (xspi->bytes_per_word == XSPI_FOUR_BITS_PER_WORD) {
 			xspi->tx_fifo = xspi_fill_tx_fifo_32;
 			xspi->rx_fifo = xspi_read_rx_fifo_32;
+
+			printk("xilinx_spi_probe 32 bytes_per_word=%d \r\n", xspi->bytes_per_word );
 		}
 	} else if (xspi->rx_bus_width == XSPI_RX_FOUR_WIRE) {
 		master->mode_bits |= SPI_TX_QUAD | SPI_RX_QUAD;
@@ -876,28 +1126,53 @@ static int xilinx_spi_probe(struct platform_device *pdev)
 	 * block to FLASH. STARTUP block don't provide clock as soon
 	 * as QSPI provides command. So first command fails.
 	 */
+	printk("xilinx_spi_probe startup_block=%d, bytes_per_word=%d\r\n", startup_block,xspi->bytes_per_word);
+	
 	if (startup_block)
 		xilinx_spi_startup_block(xspi, cs_num);
 
 	ret = spi_register_master(master);
+	printk("xilinx_spi_probe spi_register_master  ret=%d \r\n", ret);
+	
 	if (ret) {
 		dev_err(&pdev->dev, "spi_register_master failed\n");
 		goto clk_unprepare_all;
 	}
-
+    
+    
+    //XPAR_GPIO_0_BASEADDR =  ioremap(XPAR_GPIO_0_BASEADDR_PHY,XPAR_GPIO_0_SIZE);  
+    //printk("xilinx_spi_probe gpio: virt_adrress=0x%x, phy_address=0x%x\n",XPAR_GPIO_0_BASEADDR,XPAR_GPIO_0_BASEADDR_PHY);
+    //if (!XPAR_GPIO_0_BASEADDR) {
+    //    printk(KERN_ERR "fpga_driver: cannot ioremap dptx_base_adrress\n") ;
+    //    return ;
+    //}
+
+    
+    printk("---->> xilinx_spi_probe out  ret=%d \r\n", ret);
+
+    
 	return ret;
 
 clk_unprepare_all:
+    printk("xilinx_spi_probe error clk_unprepare_all \r\n");
+
 	pm_runtime_disable(&pdev->dev);
 	pm_runtime_set_suspended(&pdev->dev);
 	clk_unprepare(xspi->spi_clk);
 clk_unprepare_axi4_clk:
+    printk("xilinx_spi_probe error clk_unprepare_axi4_clk \r\n");
+
 	clk_unprepare(xspi->axi4_clk);
 clk_unprepare_axi_clk:
+    printk("xilinx_spi_probe error clk_unprepare_axi_clk \r\n");
+
 	clk_unprepare(xspi->axi_clk);
 put_master:
+    printk("xilinx_spi_probe error put_master \r\n");
+
 	spi_master_put(master);
 
+    printk("xilinx_spi_probe error out  ret=%d \r\n", ret);
 	return ret;
 }
 
@@ -930,6 +1205,14 @@ static int xilinx_spi_remove(struct platform_device *pdev)
 
 	spi_unregister_master(master);
 
+    //if(XPAR_GPIO_0_BASEADDR)
+    //{
+    //    printk("xilinx_spi_remove XPAR_GPIO_0_BASEADDR=0x%x\r\n",XPAR_GPIO_0_BASEADDR);
+    //    iounmap(XPAR_GPIO_0_BASEADDR);
+    //    XPAR_GPIO_0_BASEADDR = NULL;
+    //    printk("xilinx_spi_remove XPAR_GPIO_0_BASEADDR out\r\n");
+    //}
+
 	return 0;
 }
 
diff --git a/drivers/spi/spi-zynqmp-gqspi.c b/drivers/spi/spi-zynqmp-gqspi.c
index 2e005d2..2107c05 100644
--- a/drivers/spi/spi-zynqmp-gqspi.c
+++ b/drivers/spi/spi-zynqmp-gqspi.c
@@ -797,10 +797,33 @@ static irqreturn_t zynqmp_qspi_irq(int irq, void *dev_id)
 	int ret = IRQ_NONE;
 	u32 status, mask, dma_status = 0;
 
+    printk("zynqmp_qspi_irq xqspi->irq=%d \r\n",xqspi->irq);
+    printk("zynqmp_qspi_irq xqspi->bytes_to_transfer=%d \r\n",xqspi->bytes_to_transfer);
+    printk("zynqmp_qspi_irq xqspi->bytes_to_receive=%d \r\n",xqspi->bytes_to_receive);
+    printk("zynqmp_qspi_irq xqspi->genfifocs=%d \r\n",xqspi->genfifocs);
+    printk("zynqmp_qspi_irq xqspi->genfifobus=%d \r\n",xqspi->genfifobus);
+    printk("zynqmp_qspi_irq xqspi->dma_rx_bytes=%d \r\n",xqspi->dma_rx_bytes);
+    printk("zynqmp_qspi_irq xqspi->rx_bus_width=%d \r\n",xqspi->rx_bus_width);
+    printk("zynqmp_qspi_irq xqspi->tx_bus_width=%d \r\n",xqspi->tx_bus_width);
+    printk("zynqmp_qspi_irq xqspi->genfifoentry=%d \r\n",xqspi->genfifoentry);
+    printk("zynqmp_qspi_irq xqspi->isinstr=%d \r\n",xqspi->isinstr);
+    printk("zynqmp_qspi_irq xqspi->mode=0x%x \r\n",xqspi->mode);
+    printk("zynqmp_qspi_irq xqspi->speed_hz=%d \r\n",xqspi->speed_hz);
+    printk("zynqmp_qspi_irq xqspi->io_mode=%d \r\n",xqspi->io_mode);
+    printk("zynqmp_qspi_irq xqspi->has_tapdelay=%d \r\n",xqspi->has_tapdelay);
+    
+
 	status = zynqmp_gqspi_read(xqspi, GQSPI_ISR_OFST);
+
+	printk("zynqmp_qspi_irq status=%d \r\n",status);
+	
 	zynqmp_gqspi_write(xqspi, GQSPI_ISR_OFST, status);
 	mask = (status & ~(zynqmp_gqspi_read(xqspi, GQSPI_IMASK_OFST)));
 
+    printk("zynqmp_qspi_irq mask=0x%x \r\n",mask);
+
+    printk("zynqmp_qspi_irq GQSPI_MODE_DMA=%d \r\n",GQSPI_MODE_DMA);
+    
 	/* Read and clear DMA status */
 	if (xqspi->mode == GQSPI_MODE_DMA) {
 		dma_status =
@@ -814,6 +837,8 @@ static irqreturn_t zynqmp_qspi_irq(int irq, void *dev_id)
 		ret = IRQ_HANDLED;
 	}
 
+    printk("zynqmp_qspi_irq dma_status=0x%x \r\n",dma_status);
+    
 	if (dma_status & GQSPI_QSPIDMA_DST_I_STS_DONE_MASK) {
 		zynqmp_process_dma_irq(xqspi);
 		ret = IRQ_HANDLED;
@@ -876,6 +901,24 @@ static void zynq_qspi_setuprxdma(struct zynqmp_qspi *xqspi)
 	dma_addr_t addr;
 	u64 dma_align =  (u64)(uintptr_t)xqspi->rxbuf;
 
+    printk("zynq_qspi_setuprxdma xqspi->irq=%d \r\n",xqspi->irq);
+    printk("zynq_qspi_setuprxdma xqspi->bytes_to_transfer=%d \r\n",xqspi->bytes_to_transfer);
+    printk("zynq_qspi_setuprxdma xqspi->bytes_to_receive=%d \r\n",xqspi->bytes_to_receive);
+    printk("zynq_qspi_setuprxdma xqspi->genfifocs=%d \r\n",xqspi->genfifocs);
+    printk("zynq_qspi_setuprxdma xqspi->genfifobus=%d \r\n",xqspi->genfifobus);
+    printk("zynq_qspi_setuprxdma xqspi->dma_rx_bytes=%d \r\n",xqspi->dma_rx_bytes);
+    printk("zynq_qspi_setuprxdma xqspi->rx_bus_width=%d \r\n",xqspi->rx_bus_width);
+    printk("zynq_qspi_setuprxdma xqspi->tx_bus_width=%d \r\n",xqspi->tx_bus_width);
+    printk("zynq_qspi_setuprxdma xqspi->genfifoentry=%d \r\n",xqspi->genfifoentry);
+    printk("zynq_qspi_setuprxdma xqspi->isinstr=%d \r\n",xqspi->isinstr);
+    printk("zynq_qspi_setuprxdma xqspi->mode=0x%x \r\n",xqspi->mode);
+    printk("zynq_qspi_setuprxdma xqspi->speed_hz=%d \r\n",xqspi->speed_hz);
+    printk("zynq_qspi_setuprxdma xqspi->io_mode=%d \r\n",xqspi->io_mode);
+    printk("zynq_qspi_setuprxdma xqspi->has_tapdelay=%d \r\n",xqspi->has_tapdelay);
+
+
+    printk("zynq_qspi_setuprxdma dma_align=%d \r\n",dma_align);
+
 	if (((xqspi->bytes_to_receive < 8) || (xqspi->io_mode)) ||
 		((dma_align & GQSPI_DMA_UNALIGN) != 0x0) ||
 		is_vmalloc_addr(xqspi->rxbuf)) {
@@ -885,6 +928,8 @@ static void zynq_qspi_setuprxdma(struct zynqmp_qspi *xqspi)
 		zynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);
 		xqspi->mode = GQSPI_MODE_IO;
 		xqspi->dma_rx_bytes = 0;
+
+		printk("zynq_qspi_setuprxdma return mode=%d \r\n",xqspi->mode);
 		return;
 	}
 
@@ -912,9 +957,14 @@ static void zynq_qspi_setuprxdma(struct zynqmp_qspi *xqspi)
 	config_reg |= GQSPI_CFG_MODE_EN_DMA_MASK;
 	zynqmp_gqspi_write(xqspi, GQSPI_CONFIG_OFST, config_reg);
 
+    printk("zynq_qspi_setuprxdma mode=%d, config_reg=0x%x \r\n", xqspi->mode,config_reg);
+    
 	/* Switch to DMA mode */
 	xqspi->mode = GQSPI_MODE_DMA;
 
+    printk("zynq_qspi_setuprxdma mode=%d \r\n", xqspi->mode);
+
+    
 	/* Write the number of bytes to transfer */
 	zynqmp_gqspi_write(xqspi, GQSPI_QSPIDMA_DST_SIZE_OFST, rx_bytes);
 }
@@ -934,6 +984,12 @@ static void zynqmp_qspi_txrxsetup(struct zynqmp_qspi *xqspi,
 {
 	u32 config_reg;
 
+    printk("zynqmp_qspi_txrxsetup rxbuf=0x%x, txbuf=0x%x \r\n", xqspi->rxbuf,xqspi->txbuf);
+    printk("zynqmp_qspi_txrxsetup *genfifoentry=0x%x \r\n", *genfifoentry);
+    
+    printk("zynqmp_qspi_txrxsetup mode=0x%x \r\n", xqspi->mode);
+
+
 	/* Transmit */
 	if ((xqspi->txbuf != NULL) && (xqspi->rxbuf == NULL)) {
 		/* Setup data to be TXed */
@@ -990,6 +1046,14 @@ static int zynqmp_qspi_start_transfer(struct spi_master *master,
 	struct zynqmp_qspi *xqspi = spi_master_get_devdata(master);
 	u32 genfifoentry = 0x0, transfer_len;
 
+    printk("zynqmp_qspi_start_transfer qspi->max_speed_hz=%d \r\n",qspi->max_speed_hz);
+    printk("zynqmp_qspi_start_transfer qspi->chip_select=%d \r\n",qspi->chip_select);
+    printk("zynqmp_qspi_start_transfer qspi->bits_per_word=%d \r\n",qspi->bits_per_word);
+    printk("zynqmp_qspi_start_transfer qspi->mode=0x%x \r\n",qspi->mode);
+    printk("zynqmp_qspi_start_transfer qspi->irq=0x%x \r\n",qspi->irq);
+    printk("zynqmp_qspi_start_transfer qspi->cs_gpio=0x%x \r\n",qspi->cs_gpio);
+    
+
 	xqspi->txbuf = transfer->tx_buf;
 	xqspi->rxbuf = transfer->rx_buf;
 
@@ -1383,6 +1447,23 @@ static int zynqmp_qspi_probe(struct platform_device *pdev)
 	if (ret)
 		goto clk_dis_all;
 
+
+    printk("zynqmp_qspi_probe xqspi->irq=%d \r\n",xqspi->irq);
+    printk("zynqmp_qspi_probe xqspi->bytes_to_transfer=%d \r\n",xqspi->bytes_to_transfer);
+    printk("zynqmp_qspi_probe xqspi->bytes_to_receive=%d \r\n",xqspi->bytes_to_receive);
+    printk("zynqmp_qspi_probe xqspi->genfifocs=%d \r\n",xqspi->genfifocs);
+    printk("zynqmp_qspi_probe xqspi->genfifobus=%d \r\n",xqspi->genfifobus);
+    printk("zynqmp_qspi_probe xqspi->dma_rx_bytes=%d \r\n",xqspi->dma_rx_bytes);
+    printk("zynqmp_qspi_probe xqspi->rx_bus_width=%d \r\n",xqspi->rx_bus_width);
+    printk("zynqmp_qspi_probe xqspi->tx_bus_width=%d \r\n",xqspi->tx_bus_width);
+    printk("zynqmp_qspi_probe xqspi->genfifoentry=%d \r\n",xqspi->genfifoentry);
+    printk("zynqmp_qspi_probe xqspi->isinstr=%d \r\n",xqspi->isinstr);
+    printk("zynqmp_qspi_probe xqspi->mode=0x%x \r\n",xqspi->mode);
+    printk("zynqmp_qspi_probe xqspi->speed_hz=%d \r\n",xqspi->speed_hz);
+    printk("zynqmp_qspi_probe xqspi->io_mode=%d \r\n",xqspi->io_mode);
+    printk("zynqmp_qspi_probe xqspi->has_tapdelay=%d \r\n",xqspi->has_tapdelay);
+    
+
 	return 0;
 
 clk_dis_all:
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4a834dd..af86894 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1010,8 +1010,12 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 	struct spi_statistics *statm = &ctlr->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
 
+    printk("spi_transfer_one_message in spi_set_cs before \r\n");
+    
 	spi_set_cs(msg->spi, true);
 
+	printk("spi_transfer_one_message spi_set_cs out \r\n");
+
 	SPI_STATISTICS_INCREMENT_FIELD(statm, messages);
 	SPI_STATISTICS_INCREMENT_FIELD(stats, messages);
 
@@ -1024,7 +1028,10 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 		if (xfer->tx_buf || xfer->rx_buf) {
 			reinit_completion(&ctlr->xfer_completion);
 
+            printk("spi_transfer_one_message transfer_one before \r\n");
+            
 			ret = ctlr->transfer_one(ctlr, msg->spi, xfer);
+			printk("spi_transfer_one_message transfer_one out ret=%d\r\n", ret);
 			if (ret < 0) {
 				SPI_STATISTICS_INCREMENT_FIELD(statm,
 							       errors);
@@ -1039,7 +1046,13 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 				ret = 0;
 				ms = 8LL * 1000LL * xfer->len;
 				do_div(ms, xfer->speed_hz);
-				ms += ms + 200; /* some tolerance */
+				//ms += ms + 200; /* some tolerance */
+
+                               
+                //ms += ms + 200; /* some tolerance */
+                
+				ms += ms + 2000; /* some tolerance */
+				
 
 				if (ms > UINT_MAX)
 					ms = UINT_MAX;
@@ -1048,6 +1061,7 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 								 msecs_to_jiffies(ms));
 			}
 
+            printk("spi_transfer_one_message wait_for_completion_timeout out ms=%d\r\n", ms);
 			if (ms == 0) {
 				SPI_STATISTICS_INCREMENT_FIELD(statm,
 							       timedout);
@@ -1095,7 +1109,8 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 out:
 	if (ret != 0 || !keep_cs)
 		spi_set_cs(msg->spi, false);
-
+    printk("spi_transfer_one_message spi_set_cs false out \r\n");
+    
 	if (msg->status == -EINPROGRESS)
 		msg->status = ret;
 
@@ -1106,6 +1121,8 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 
 	spi_finalize_current_message(ctlr);
 
+    printk("spi_transfer_one_message out ret=%d \r\n", ret);
+    
 	return ret;
 }
 
@@ -1142,6 +1159,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 	bool was_busy = false;
 	int ret;
 
+    printk("__spi_pump_messages in \r\n");
+
+    
 	/* Lock queue */
 	spin_lock_irqsave(&ctlr->queue_lock, flags);
 
@@ -1158,6 +1178,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		return;
 	}
 
+    printk("__spi_pump_messages running=%d \r\n", ctlr->running);
+
+    
 	/* Check if the queue is idle */
 	if (list_empty(&ctlr->queue) || !ctlr->running) {
 		if (!ctlr->busy) {
@@ -1165,6 +1188,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 			return;
 		}
 
+		printk("__spi_pump_messages kthread_queue_work before  \r\n" );
+		
+
 		/* Only do teardown in the thread */
 		if (!in_kthread) {
 			kthread_queue_work(&ctlr->kworker,
@@ -1210,6 +1236,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 
 	mutex_lock(&ctlr->io_mutex);
 
+    printk("__spi_pump_messages pm_runtime_get_sync before  \r\n" );
+            
+
 	if (!was_busy && ctlr->auto_runtime_pm) {
 		ret = pm_runtime_get_sync(ctlr->dev.parent);
 		if (ret < 0) {
@@ -1224,6 +1253,8 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 	if (!was_busy)
 		trace_spi_controller_busy(ctlr);
 
+    printk("__spi_pump_messages pm_runtime_put before  \r\n" );
+    
 	if (!was_busy && ctlr->prepare_transfer_hardware) {
 		ret = ctlr->prepare_transfer_hardware(ctlr);
 		if (ret) {
@@ -1237,6 +1268,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		}
 	}
 
+    printk("__spi_pump_messages trace_spi_message_start before  \r\n" );
+    
+
 	trace_spi_message_start(ctlr->cur_msg);
 
 	if (ctlr->prepare_message) {
@@ -1251,6 +1285,9 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		ctlr->cur_msg_prepared = true;
 	}
 
+    printk("__spi_pump_messages spi_map_msg before  \r\n" );
+    
+
 	ret = spi_map_msg(ctlr, ctlr->cur_msg);
 	if (ret) {
 		ctlr->cur_msg->status = ret;
@@ -1258,7 +1295,13 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		goto out;
 	}
 
+    printk("__spi_pump_messages transfer_one_message before  \r\n" );
+    
+
 	ret = ctlr->transfer_one_message(ctlr, ctlr->cur_msg);
+
+	printk("__spi_pump_messages transfer_one_message out ret=%d  \r\n", ret);
+
 	if (ret) {
 		dev_err(&ctlr->dev,
 			"failed to transfer one message from queue\n");
@@ -3104,6 +3147,8 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 	SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics, spi_sync);
 	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
 
+    printk("__spi_sync in\r\n");
+    
 	/* If we're not using the legacy transfer method then we will
 	 * try to transfer in the calling context so special case.
 	 * This code would be less tricky if we could remove the
@@ -3114,7 +3159,12 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 
 		trace_spi_message_submit(message);
 
+        printk("__spi_sync __spi_queued_transfer before\r\n");
+        
 		status = __spi_queued_transfer(spi, message, false);
+		
+        printk("__spi_sync __spi_queued_transfer out status=%d\r\n", status);
+        
 
 		spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
 	} else {
@@ -3130,11 +3180,15 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 						       spi_sync_immediate);
 			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
 						       spi_sync_immediate);
+
+			printk("__spi_sync __spi_pump_messages before\r\n");
 			__spi_pump_messages(ctlr, false);
+			printk("\r\n__spi_sync __spi_pump_messages out \r\n");
 		}
 
 		wait_for_completion(&done);
 		status = message->status;
+		printk("__spi_sync wait_for_completion out status=%d\r\n", status);
 	}
 	message->context = NULL;
 	return status;
@@ -3300,6 +3354,9 @@ int spi_write_then_read(struct spi_device *spi,
 		local_buf = buf;
 	}
 
+    printk("spi_write_then_read  n_tx=%d, n_rx=%d\r\n", n_tx, n_rx);
+
+    
 	spi_message_init(&message);
 	memset(x, 0, sizeof(x));
 	if (n_tx) {
@@ -3522,6 +3579,14 @@ static int __init spi_init(void)
 			goto err3;
 	}
 
+
+
+	printk("spi_init status=%d\r\n", status);
+
+
+
+	
+
 	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
 		WARN_ON(of_reconfig_notifier_register(&spi_of_notifier));
 	if (IS_ENABLED(CONFIG_ACPI))
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index cda1071..5a2acfe 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -106,11 +106,15 @@ spidev_sync(struct spidev_data *spidev, struct spi_message *message)
 	spi = spidev->spi;
 	spin_unlock_irq(&spidev->spi_lock);
 
+    printk("spidev_sync spi_sync before \r\n");
+
 	if (spi == NULL)
 		status = -ESHUTDOWN;
 	else
 		status = spi_sync(spi, message);
 
+    printk("spidev_sync spi_sync out status=%d\r\n", status);
+
 	if (status == 0)
 		status = message->actual_length;
 
@@ -127,6 +131,8 @@ spidev_sync_write(struct spidev_data *spidev, size_t len)
 		};
 	struct spi_message	m;
 
+    printk("spidev_sync_write len=%d\r\n", len);
+    
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 	return spidev_sync(spidev, &m);
@@ -142,6 +148,9 @@ spidev_sync_read(struct spidev_data *spidev, size_t len)
 		};
 	struct spi_message	m;
 
+    printk("spidev_sync_read len=%d\r\n", len);
+    
+
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 	return spidev_sync(spidev, &m);
@@ -164,6 +173,9 @@ spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
 
 	mutex_lock(&spidev->buf_lock);
 	status = spidev_sync_read(spidev, count);
+
+	printk("spidev_read count=%d, status=%d\r\n",count,status);
+	
 	if (status > 0) {
 		unsigned long	missing;
 
@@ -195,15 +207,41 @@ spidev_write(struct file *filp, const char __user *buf,
 
 	mutex_lock(&spidev->buf_lock);
 	missing = copy_from_user(spidev->tx_buffer, buf, count);
+
+    printk("spidev_write count=%d\r\n",count);
+	
 	if (missing == 0)
 		status = spidev_sync_write(spidev, count);
 	else
 		status = -EFAULT;
+
+	printk("spidev_write out status=%d\r\n",status);
+
+	
 	mutex_unlock(&spidev->buf_lock);
 
 	return status;
 }
 
+bool spidev_update_stripe(const u8 opcode)
+{
+	if (opcode ==  0x20 ||
+	    opcode ==  0x52 ||
+	    opcode ==  0xc7 ||
+	    opcode ==  0xd8 ||
+	    opcode ==  0x5c ||
+	    opcode ==  0xdc ||
+	    opcode ==  0x21 ||
+	    opcode ==  0x01 ||
+	    opcode ==  0xc5 ||
+	    opcode ==  0x17 ||
+	    opcode ==  0x3e)
+		return false;
+
+	return true;
+}
+
+
 static int spidev_message(struct spidev_data *spidev,
 		struct spi_ioc_transfer *u_xfers, unsigned n_xfers)
 {
@@ -215,6 +253,8 @@ static int spidev_message(struct spidev_data *spidev,
 	u8			*tx_buf, *rx_buf;
 	int			status = -EFAULT;
 
+	int i = 0;
+
 	spi_message_init(&msg);
 	k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
 	if (k_xfers == NULL)
@@ -229,11 +269,41 @@ static int spidev_message(struct spidev_data *spidev,
 	total = 0;
 	tx_total = 0;
 	rx_total = 0;
+
+	printk("spidev_message n_xfers=0x%0x, k_xfers=0x%0x,u_xfers=0x%0x\r\n",n_xfers,k_xfers,u_xfers);
+	printk("spidev_message tx_buf=0x%0x, rx_buf=0x%0x \r\n",tx_buf,rx_buf);
+	if(tx_buf != NULL )
+	{
+	    printk("spidev_message tx_buf=0x%x,0x%x,0x%x,0x%x \r\n",tx_buf[0],tx_buf[1],tx_buf[2],tx_buf[3]);
+	}
+	if(rx_buf != NULL )
+	{
+	    printk("spidev_message tx_buf=0x%x,0x%x,0x%x,0x%x \r\n",rx_buf[0],rx_buf[1],rx_buf[2],rx_buf[3]);
+	}
+	
+
+	
 	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
 			n;
 			n--, k_tmp++, u_tmp++) {
 		k_tmp->len = u_tmp->len;
 
+        printk("spidev_message rx_buf=0x%x, tx_buf=0x%x \r\n", u_tmp->rx_buf,u_tmp->tx_buf);
+
+        printk("spidev_message len=%d, speed_hz=%d \r\n", u_tmp->len,u_tmp->speed_hz);
+
+        
+        printk("spidev_message delay_usecs=%d \r\n", u_tmp->delay_usecs);
+        printk("spidev_message bits_per_word=%d \r\n", u_tmp->bits_per_word);
+        printk("spidev_message cs_change=%d \r\n", u_tmp->cs_change);
+        printk("spidev_message tx_nbits=%d \r\n", u_tmp->tx_nbits);
+        printk("spidev_message rx_nbits=%d \r\n", u_tmp->rx_nbits);
+
+
+
+
+		
+
 		total += k_tmp->len;
 		/* Since the function returns the total length of transfers
 		 * on success, restrict the total to positive int values to
@@ -254,6 +324,16 @@ static int spidev_message(struct spidev_data *spidev,
 			}
 			k_tmp->rx_buf = rx_buf;
 			rx_buf += k_tmp->len;
+
+			if(u_tmp->tx_buf != NULL)
+			{
+			    printk("spidev_message tx_buf[0]=%d, tx_buf=0x%x \r\n", tx_buf[0],u_tmp->tx_buf);
+			    if(tx_buf[0] == 0x9f)
+			    {
+			        k_tmp->stripe = 1;
+			        printk("spidev_message stripe=%d \r\n", k_tmp->stripe);
+			    }
+			}
 		}
 		if (u_tmp->tx_buf) {
 			/* this transfer needs space in TX bounce buffer */
@@ -263,11 +343,44 @@ static int spidev_message(struct spidev_data *spidev,
 				goto done;
 			}
 			k_tmp->tx_buf = tx_buf;
+
+			if(u_tmp->tx_buf != NULL)
+			{
+			    printk("spidev_message tx_buf[0]=%d, len=%d \r\n", tx_buf[0], k_tmp->len);
+			}
+			
+			
 			if (copy_from_user(tx_buf, (const u8 __user *)
 						(uintptr_t) u_tmp->tx_buf,
 					u_tmp->len))
 				goto done;
+
+
+			if(u_tmp->tx_buf != NULL)
+			{
+			    printk("spidev_message tx_buf[0]=%d, len=%d \r\n", tx_buf[0], k_tmp->len);
+
+			    for(i = 0; i < k_tmp->len; i++)
+			    {
+			        printk("spidev_message tx_buf[%d]=%d \r\n",i, tx_buf[i]);
+			    }
+
+			    
+			}
+
 			tx_buf += k_tmp->len;
+
+			if(u_tmp->tx_buf != NULL)
+			{
+			    printk("spidev_message tx_buf[0]=%d, len=%d \r\n", tx_buf[0], k_tmp->len);
+
+			    for(i = 0; i < k_tmp->len; i++)
+			    {
+			        printk("spidev_message tx_buf[%d]=%d \r\n",i, tx_buf[i]);
+			    }
+
+			    
+			}
 		}
 
 		k_tmp->cs_change = !!u_tmp->cs_change;
@@ -278,6 +391,18 @@ static int spidev_message(struct spidev_data *spidev,
 		k_tmp->speed_hz = u_tmp->speed_hz;
 		if (!k_tmp->speed_hz)
 			k_tmp->speed_hz = spidev->speed_hz;
+
+		if(k_tmp->tx_nbits == 0 &&  k_tmp->rx_nbits == 0 && k_tmp->len == 5)
+		{
+		    k_tmp->tx_nbits = 4;
+		    k_tmp->dummy = k_tmp->len * 8;
+		}
+
+		if(k_tmp->rx_nbits > 0)
+		{
+		    k_tmp->stripe = 1;
+		}
+		
 #ifdef VERBOSE
 		dev_dbg(&spidev->spi->dev,
 			"  xfer len %u %s%s%s%dbits %u usec %uHz\n",
@@ -290,9 +415,20 @@ static int spidev_message(struct spidev_data *spidev,
 			u_tmp->speed_hz ? : spidev->spi->max_speed_hz);
 #endif
 		spi_message_add_tail(k_tmp, &msg);
+
+
+
+		printk("spidev_message len=%d, cs_change=%d, tx_nbits=%d, rx_nbits=%d, bits_per_word=%d, delay_usecs=%d, speed_hz=%d, dummy=%d, stripe=%d \n",
+            k_tmp->len, u_tmp->cs_change, k_tmp->tx_nbits, k_tmp->rx_nbits,
+            k_tmp->bits_per_word, k_tmp->delay_usecs, k_tmp->speed_hz, k_tmp->dummy,
+            k_tmp->stripe);
 	}
 
 	status = spidev_sync(spidev, &msg);
+
+	printk("spidev_message spidev_sync out status=%d\r\n", status);
+
+	
 	if (status < 0)
 		goto done;
 
@@ -311,6 +447,8 @@ static int spidev_message(struct spidev_data *spidev,
 	}
 	status = total;
 
+    printk("spidev_message all out status=%d\r\n", status);
+    
 done:
 	kfree(k_xfers);
 	return status;
@@ -372,6 +510,9 @@ spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	 */
 	mutex_lock(&spidev->buf_lock);
 
+    printk("spidev_ioctl cmd=0x%x\r\n", cmd);
+    
+
 	switch (cmd) {
 	/* read requests */
 	case SPI_IOC_RD_MODE:
@@ -381,6 +522,7 @@ spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	case SPI_IOC_RD_MODE32:
 		retval = put_user(spi->mode & SPI_MODE_MASK,
 					(__u32 __user *)arg);
+		printk("SPI_IOC_RD_MODE32 spi->mode=0x%x\r\n",spi->mode);
 		break;
 	case SPI_IOC_RD_LSB_FIRST:
 		retval = put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
@@ -410,6 +552,7 @@ spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 
 			tmp |= spi->mode & ~SPI_MODE_MASK;
 			spi->mode = (u16)tmp;
+			printk("SPI_IOC_WR_MODE32 spi->mode=0x%x\r\n",spi->mode);
 			retval = spi_setup(spi);
 			if (retval < 0)
 				spi->mode = save;
@@ -467,6 +610,22 @@ spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		/* Check message and copy into scratch area */
 		ioc = spidev_get_ioc_message(cmd,
 				(struct spi_ioc_transfer __user *)arg, &n_ioc);
+
+		printk("ioc->len=%d \r\n", ioc->len);
+		printk("ioc->speed_hz=%d \r\n", ioc->speed_hz);
+		
+		printk("ioc->delay_usecs=%d \r\n", ioc->delay_usecs);
+		printk("ioc->bits_per_word=%d \r\n", ioc->bits_per_word);
+		printk("ioc->cs_change=%d \r\n", ioc->cs_change);
+		printk("ioc->tx_nbits=%d \r\n", ioc->tx_nbits);
+		printk("ioc->rx_nbits=%d \r\n", ioc->rx_nbits);
+		printk("ioc->pad=%d \r\n", ioc->pad);
+
+        printk("ioc->tx_buf=0x%x \r\n", ioc->tx_buf);
+        printk("ioc->tx_buf=0x%x \r\n", ioc->tx_buf);
+        printk("ioc->tx_buf=0x%x \r\n", ioc->tx_buf);
+        printk("ioc->tx_buf=0x%x \r\n", ioc->tx_buf);
+		
 		if (IS_ERR(ioc)) {
 			retval = PTR_ERR(ioc);
 			break;
@@ -474,8 +633,12 @@ spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		if (!ioc)
 			break;	/* n_ioc is also 0 */
 
+        printk("n_ioc=%d \r\n", n_ioc);
+        
 		/* translate to spi_message, execute */
 		retval = spidev_message(spidev, ioc, n_ioc);
+
+		
 		kfree(ioc);
 		break;
 	}
@@ -719,6 +882,10 @@ static int spidev_probe(struct spi_device *spi)
 	int			status;
 	unsigned long		minor;
 
+    printk("spidev_probe in \r\n");
+
+
+    
 	/*
 	 * spidev should never be referenced in DT without a specific
 	 * compatible string, it is a Linux implementation thing
@@ -730,13 +897,25 @@ static int spidev_probe(struct spi_device *spi)
 			!of_match_device(spidev_dt_ids, &spi->dev));
 	}
 
+    
+    printk("spidev_probe spidev_probe_acpi before \r\n");
+
+
 	spidev_probe_acpi(spi);
 
+
+	printk("spidev_probe spidev_probe_acpi out \r\n");
+
+
+	
+
 	/* Allocate driver data */
 	spidev = kzalloc(sizeof(*spidev), GFP_KERNEL);
 	if (!spidev)
 		return -ENOMEM;
 
+    printk("spidev_probe kzalloc out \r\n");
+    
 	/* Initialize the driver data */
 	spidev->spi = spi;
 	spin_lock_init(&spidev->spi_lock);
@@ -749,6 +928,10 @@ static int spidev_probe(struct spi_device *spi)
 	 */
 	mutex_lock(&device_list_lock);
 	minor = find_first_zero_bit(minors, N_SPI_MINORS);
+
+	printk("spidev_probe find_first_zero_bit out minor=%d \r\n", minor);
+
+	
 	if (minor < N_SPI_MINORS) {
 		struct device *dev;
 
@@ -756,11 +939,17 @@ static int spidev_probe(struct spi_device *spi)
 		dev = device_create(spidev_class, &spi->dev, spidev->devt,
 				    spidev, "spidev%d.%d",
 				    spi->master->bus_num, spi->chip_select);
+
+	    printk("spidev_probe device_create out bus_num=%d, chip_select=%d \r\n", spi->master->bus_num, spi->chip_select);
+	   
 		status = PTR_ERR_OR_ZERO(dev);
 	} else {
 		dev_dbg(&spi->dev, "no minor number available!\n");
 		status = -ENODEV;
 	}
+
+	printk("spidev_probe device_create out status=%d \r\n", status);
+	
 	if (status == 0) {
 		set_bit(minor, minors);
 		list_add(&spidev->device_entry, &device_list);
@@ -769,11 +958,17 @@ static int spidev_probe(struct spi_device *spi)
 
 	spidev->speed_hz = spi->max_speed_hz;
 
+    printk("spidev_probe list_add out speed_hz=%d \r\n", spidev->speed_hz);
+
+    
 	if (status == 0)
 		spi_set_drvdata(spi, spidev);
 	else
 		kfree(spidev);
 
+    printk("spidev_probe out status=%d \r\n", status);
+
+
 	return status;
 }
 
-- 
2.7.4

